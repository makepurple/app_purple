type AcceptFriendshipPayload implements MutationPayload {
  query: Query!
  record: Friendship!
}

# The `BigInt` scalar type represents non-fractional signed whole numeric values.
# @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt
scalar BigInt

# The `Byte` scalar type represents byte value as a Buffer
scalar Bytes

type Comment {
  author: User!
  authorId: String!
  content: Json
  createdAt: DateTime!
  downvoters(after: String, before: String, first: Int, last: Int, where: UserWhereInput): UserConnection!
  id: ID!
  parent: Comment
  parentId: String
  post: Post
  postId: String
  replies(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, where: CommentWhereInput): CommentConnection!
  updatedAt: DateTime!
  upvoters(after: String, before: String, first: Int, last: Int, where: UserWhereInput): UserConnection!
  upvotes: Int!

  # How the viewer has voted on this comment.
  #
  # true: upvoted
  # false: downvoted
  # null: didn't vote
  viewerUpvote: Boolean
}

# Relay-style connection for Comment types.
type CommentConnection implements Connection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input CommentCreateInput {
  content: Json
  parent: CommentWhereUniqueInput
  post: PostWhereUniqueInput
}

# Relay-style edge for Comment types.
type CommentEdge {
  cursor: String!
  node: Comment!
}

input CommentOrderByInput {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input CommentUpdateInput {
  content: Json
}

input CommentWhereInput {
  author: UserWhereInput
  authorId: StringNullableFilter
  createdAt: DateTimeNullableFilter
  post: PostWhereInput
  postId: StringNullableFilter
  updatedAt: DateTimeNullableFilter
}

input CommentWhereUniqueInput {
  id: String
}

interface Connection {
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreateCommentPayload implements MutationPayload {
  query: Query!
  record: Comment!
}

type CreateExperiencePayload implements MutationPayload {
  query: Query!
  record: Experience!
}

type CreatePostPayload implements MutationPayload {
  query: Query!
  record: Post!
}

type CreateRepositoryPayload implements MutationPayload {
  query: Query!
  record: Repository!
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

input DateTimeNullableFilter {
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
}

# An arbitrary-precision Decimal type
scalar Decimal

type DeleteCommentPayload implements MutationPayload {
  query: Query!
  record: Comment!
}

type DeleteExperiencePayload implements MutationPayload {
  query: Query!
  record: Experience!
}

type DeleteFriendshipPayload implements MutationPayload {
  query: Query!
  record: Friendship!
}

type DeletePostPayload implements MutationPayload {
  query: Query!
  record: Post!
}

type DownvoteCommentPayload implements MutationPayload {
  query: Query!
  record: Comment!
}

input EnumExperienceTypeNullableFilter {
  equals: ExperienceType
  in: [ExperienceType!]
  notIn: [ExperienceType!]
}

type Experience {
  endDate: DateTime
  highlights: [String!]!
  id: ID!
  location: String
  organization: Organization!
  organizationName: String!
  positionName: String!
  startDate: DateTime!
  type: ExperienceType
  user: User!
}

# Relay-style connection for Experience types.
type ExperienceConnection implements Connection {
  edges: [ExperienceEdge!]!
  nodes: [Experience!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ExperienceCreateInput {
  endDate: DateTime
  highlights: [String!]
  location: String
  organizationName: String!
  positionName: String!
  startDate: DateTime!
  type: ExperienceType
}

# Relay-style edge for Experience types.
type ExperienceEdge {
  cursor: String!
  node: Experience!
}

input ExperienceOrderByInput {
  endDate: SortOrder
  startDate: SortOrder
}

enum ExperienceType {
  Contract
  FullTime
  Intern
  OpenSource
  PartTime
}

input ExperienceUpdateInput {
  endDate: DateTime
  highlights: [String!]
  location: String
  organizationName: String
  positionName: String
  startDate: DateTime
  type: ExperienceType
}

input ExperienceWhereInput {
  organizationName: StringNullableFilter
  positionName: StringNullableFilter
  type: EnumExperienceTypeNullableFilter
  user: UserWhereInput
  userId: String
}

input ExperienceWhereUniqueInput {
  id: String!
}

type Follow {
  createdAt: DateTime!
  follower: User!
  following: Following!
  id: ID!
}

type FollowConnection implements Connection {
  edges: [FollowEdge!]!
  nodes: [Follow!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FollowEdge {
  cursor: String!
  node: Follow!
}

type FollowSkillPayload implements MutationPayload {
  query: Query!
  record: Follow!
}

type FollowUserPayload implements MutationPayload {
  query: Query!
  record: Follow!
}

input FollowWhereInput {
  skill: SkillWhereInput
  type: FollowingType
  user: UserWhereInput
}

input FollowWhereUniqueInput {
  id: String
}

union Following = Skill | User

enum FollowingType {
  Skill
  User
}

type Friendship {
  friender: User!
  frienderId: String!
  friending: User!
  friendingId: String!
  id: ID!
  rejected: Boolean!
  updatedAt: DateTime!
}

input FriendshipWhereUniqueInput {
  id: String
}

type GitHubLanguage {
  color: String
  id: String!
  name: String!
}

type GitHubLicense {
  description: String
  id: String!
  name: String!
  nickname: String
  spdxId: String
  url: URL
}

type GitHubOrganization implements GitHubRepositoryOwner {
  avatarUrl: URL!
  description: String
  id: String!
  login: String!
  name: String
  organization: Organization!
  url: URL!
}

type GitHubRepository {
  description: String
  forkCount: Int!
  id: String!
  issueCount: Int!
  licenseInfo: GitHubLicense
  name: String!
  owner: GitHubRepositoryOwner!
  primaryLanguage: GitHubLanguage
  pullRequestCount: Int!
  pushedAt: DateTime
  repository: Repository
  stargazerCount: Int!
  url: URL!
}

interface GitHubRepositoryOwner {
  avatarUrl: URL!
  id: String!
  login: String!
  url: URL!
}

# Data for a user from that user's connected GitHub account.
type GitHubUser implements GitHubRepositoryOwner {
  avatarUrl: URL!
  bio: String
  company: String
  id: String!
  login: String!
  name: String
  topLanguages: TopLanguages!
  twitterUsername: String
  url: URL!
  user: User!
  websiteUrl: String
}

# The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar Json @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

# Root mutation type
type Mutation {
  acceptFriendship(
    # Find friendship from requester -> viewer
    where: FriendshipWhereUniqueInput!
  ): AcceptFriendshipPayload!
  createComment(data: CommentCreateInput!): CreateCommentPayload!
  createExperience(data: ExperienceCreateInput!): CreateExperiencePayload!

  # Creates a new draft if the user doesn't have a draft pending to be published already
  createPost: CreatePostPayload!
  createRepository(data: RepositoryCreateInput!): CreateRepositoryPayload!
  deleteComment(where: CommentWhereUniqueInput!): DeleteCommentPayload!

  # Users can delete their own experiences.
  deleteExperience(where: ExperienceWhereUniqueInput!): DeleteExperiencePayload!
  deleteFriendship(
    # Find friendship from viewer -> friend
    where: FriendshipWhereUniqueInput!
  ): DeleteFriendshipPayload!

  # Users can delete their own posts.
  deletePost(where: PostWhereUniqueInput!): DeletePostPayload!
  followSkill(where: SkillWhereUniqueInput!): FollowUserPayload!
  followUser(where: UserWhereUniqueInput!): FollowUserPayload!
  ok: Boolean!
  publishPost(data: PostPublishInput, where: PostWhereUniqueInput!): PublishPostPayload!
  rejectFriendship(
    # Find friendship from requester -> viewer
    where: FriendshipWhereUniqueInput!
  ): RejectFriendshipPayload!
  removePostThumbnail(where: PostWhereUniqueInput!): RemovePostThumbnailPayload!
  requestFriendship(where: UserWhereUniqueInput!): RequestFriendshipPayload!
  unfollowSkill(where: FollowWhereUniqueInput!): UnfollowSkillPayload!
  unfollowUser(where: FollowWhereUniqueInput!): UnfollowUserPayload!
  unvoteComment(where: CommentWhereUniqueInput!): UnvoteCommentPayload!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): UpdateCommentPayload!
  updateDesiredSkills(data: UpdateDesiredSkillsInput!): UpdateDesiredSkillsPayload!
  updateExperience(data: ExperienceUpdateInput!, where: ExperienceWhereUniqueInput!): UpdateExperiencePayload!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): UpdatePostPayload!
  updatePostDraft(data: PostDraftUpdateInput!, where: PostWhereUniqueInput!): UpdatePostDraftPayload!
  updateRepository(data: RepositoryUpdateInput!, where: RepositoryWhereUniqueInput!): UpdateRepositoryPayload!
  updateSkills(data: UpdateSkillsInput!): UpdateSkillsPayload!
  updateUserFromGitHub: UpdateUserFromGitHubPayload!
  uploadPostImage(data: UploadPostImageInput!, where: PostWhereUniqueInput!): UploadPostImagePayload!
  upvoteComment(data: UpvoteCommentInput!, where: CommentWhereUniqueInput!): UpvoteCommentPayload!
  upvotePost(where: PostWhereUniqueInput!): UpvotePostPayload!
  viewer: User
}

interface MutationPayload {
  query: Query!
}

type Organization {
  experiences: [Experience!]!
  github: GitHubOrganization!
  id: ID!
  name: String!
}

# Page info for relay-style pagination connections.
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Post {
  author: User!
  authorName: String!
  comments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, where: CommentWhereInput): CommentConnection!
  content: Json
  createdAt: DateTime!
  description: String
  downvoters(after: String, before: String, first: Int, last: Int, where: UserWhereInput): UserConnection!
  id: ID!
  images: [PostImage!]!
  publishedAt: DateTime
  readTime: Int
  thumbnailUrl: String
  title: String
  updatedAt: DateTime!
  upvoters(after: String, before: String, first: Int, last: Int, where: UserWhereInput): UserConnection!
  upvotes: Int!
  urlSlug: String!

  # How the viewer has voted on this post.
  #
  # true: upvoted
  # false: downvoted
  # null: didn't vote
  viewerUpvote: Boolean
}

input PostAuthorNameUrlSlugCompoundUniqueInput {
  authorName: String!
  urlSlug: String!
}

# Relay-style connection for Post types.
type PostConnection implements Connection {
  edges: [PostEdge!]!
  nodes: [Post!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PostDraftUpdateInput {
  content: Json
  description: String
  thumbnailUrl: String
  title: String
}

# Relay-style edge for Post types.
type PostEdge {
  cursor: String!
  node: Post!
}

type PostImage {
  id: ID!
  post: Post!
  postId: String!
  url: String!
}

input PostPublishInput {
  content: Json
  description: String
  readTime: Int
  thumbnailUrl: String
  title: String
}

input PostUpdateInput {
  content: Json
  description: String
  readTime: Int
  thumbnailUrl: String
}

input PostWhereInput {
  author: UserWhereInput
  authorName: StringNullableFilter
  urlSlug: StringNullableFilter
}

input PostWhereUniqueInput {
  authorName_urlSlug: PostAuthorNameUrlSlugCompoundUniqueInput
  id: String
}

type PublishPostPayload implements MutationPayload {
  query: Query!
  record: Post!
}

# Root query type
type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, where: CommentWhereInput): CommentConnection!
  experiences(after: String, before: String, first: Int, last: Int, orderBy: ExperienceOrderByInput, where: ExperienceWhereInput): ExperienceConnection!
  ok: Boolean!

  # A user-created post.
  post(where: PostWhereUniqueInput!): Post
  postDraft: Post

  # Relay-style connection on Post types.
  posts(after: String, before: String, first: Int, last: Int, where: PostWhereInput): PostConnection!
  repositories(after: String, before: String, first: Int, last: Int, where: RepositoryWhereInput!): RepositoryConnection!
  suggestExperiences(first: Int, where: SuggestExperiencesWhereInput!): SuggestExperiences!
  suggestFriends(after: String, first: Int, where: SuggestFriendsWhereInput!): UserConnection!
  suggestRepositories(first: Int, where: SuggestRepositoriesWhereInput!): SuggestRepositories!
  suggestSkills(first: Int, where: SuggestSkillsWhereInput!): SuggestSkills!
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: [UserOrderByInput!], where: UserWhereInput): UserConnection!
  viewer: User
  viewerActivityFeed(after: String, before: String, first: Int, last: Int, where: UserActivityWhereInput): UserActivityItemConnection!
}

type RejectFriendshipPayload implements MutationPayload {
  query: Query!
  record: Friendship!
}

type RemovePostThumbnailPayload implements MutationPayload {
  query: Query!
  record: Post
}

type Repository {
  github: GitHubRepository!
  id: ID!
  name: String!
  owner: String!
  skills: [Skill!]!
  user: User!
}

# Relay-style connection for Repository types.
type RepositoryConnection implements Connection {
  edges: [RepositoryEdge!]!
  nodes: [Repository!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input RepositoryCreateInput {
  name: String!
}

# Relay-style edge for Repository type
type RepositoryEdge {
  cursor: String!
  node: Repository!
}

input RepositoryNameOwnerCompoundUniqueInput {
  name: String!
  owner: String!
}

input RepositoryUpdateInput {
  skills: [SkillWhereUniqueInput!]
}

input RepositoryWhereInput {
  name: StringNullableFilter
  owner: StringNullableFilter
  user: UserWhereInput
}

input RepositoryWhereUniqueInput {
  id: String
  name_owner: RepositoryNameOwnerCompoundUniqueInput
}

type RequestFriendshipPayload implements MutationPayload {
  query: Query!
  record: Friendship!
}

type Skill {
  desiringUsers: [User!]!
  id: ID!
  name: String!
  owner: String!
  users: [User!]!
}

type SkillConnection implements Connection {
  edges: [SkillEdge!]!
  nodes: [Skill!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SkillEdge {
  cursor: String!
  node: Skill!
}

input SkillNameOwnerCompoundUniqueInput {
  name: String!
  owner: String!
}

input SkillWhereInput {
  AND: [SkillWhereInput!]
  name: StringNullableFilter
  owner: StringNullableFilter
}

input SkillWhereUniqueInput {
  id: String
  name_owner: SkillNameOwnerCompoundUniqueInput
}

enum SortOrder {
  Asc
  Desc
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  in: [String!]
  notIn: [String!]
  startsWith: String
}

type SuggestExperiences {
  nodes: [GitHubOrganization!]!
  totalCount: Int!
}

input SuggestExperiencesWhereInput {
  name: String!
}

input SuggestFriendsWeightsInput {
  desiredSkillsOverlap: Float = 1
  skillsOverlap: Float = 1
}

input SuggestFriendsWhereInput {
  # The min % overlap of suggested users' skills to the viewer's desired-skills.
  #
  # This is clamped to [0, 1], and is 0 by default.
  desiredSkillsThreshold: Float = 0

  # Each suggested user's scoring metric (for ordering), can be randomly reduced by a % which is the jitter. The larger the jitter, the more random the results can be.
  #
  # This is clamped to [0, 1], and is 0.15 by default.
  jitter: Float = 0.15

  # Seeds the jitter, so that pagination will be deterministic on the same seed.
  #
  # If not provided, the results will be non-deterministically random.
  jitterSeed: Int

  # Filters suggested users by their known skills.
  skills: SkillWhereInput

  # The min % overlap of suggested users' skills to the viewer's skills.
  #
  # This is clamped to [0, 1], and is 0 by default.
  skillsThreshold: Float = 0
  weights: SuggestFriendsWeightsInput = {desiredSkillsOverlap: 1, skillsOverlap: 1}
}

type SuggestRepositories {
  nodes: [GitHubRepository!]!
  totalCount: Int!
}

input SuggestRepositoriesWhereInput {
  name: String!
}

type SuggestSkills {
  nodes: [GitHubRepository!]!
  totalCount: Int!
}

input SuggestSkillsWhereInput {
  name: String!
  owner: String!
}

# One of the most used languages by a user
type TopLanguage {
  # The color of the language, defined by GitHub
  color: String!

  # The name of the language.
  name: String!

  # The sum of number of bytes written across all owned repositories in this language.
  size: Int!
}

# The most used languages by a user, determined by number of bytes written to repositories owned by the user on GitHub.
type TopLanguages {
  nodes: [TopLanguage!]!

  # The total number of languages across all owned repositories.
  totalCount: Int!

  # The total number of bytes written across all owned repositories across all languages.
  totalSize: Int!
}

# A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
scalar URL

type UnfollowSkillPayload implements MutationPayload {
  query: Query!
  record: Follow!
}

type UnfollowUserPayload implements MutationPayload {
  query: Query!
  record: Follow!
}

type UnvoteCommentPayload implements MutationPayload {
  query: Query!
  record: Comment!
}

type UpdateCommentPayload implements MutationPayload {
  query: Query!
  record: Comment!
}

input UpdateDesiredSkillsInput {
  skills: [SkillWhereUniqueInput!]!
}

type UpdateDesiredSkillsPayload implements MutationPayload {
  query: Query!
  record: User!
}

type UpdateExperiencePayload implements MutationPayload {
  query: Query!
  record: Experience!
}

type UpdatePostDraftPayload implements MutationPayload {
  query: Query!
  record: Post!
}

type UpdatePostPayload implements MutationPayload {
  query: Query!
  record: Post!
}

type UpdateRepositoryPayload implements MutationPayload {
  query: Query!
  record: Repository!
}

input UpdateSkillsInput {
  skills: [SkillWhereUniqueInput!]!
}

type UpdateSkillsPayload implements MutationPayload {
  query: Query!
  record: User!
}

type UpdateUserFromGitHubPayload implements MutationPayload {
  query: Query!
  record: User!
}

# The `Upload` scalar type represents a file upload.
scalar Upload

input UploadPostImageInput {
  # The file of the image to be uploaded
  image: Upload!
}

type UploadPostImagePayload implements MutationPayload {
  query: Query!
  record: PostImage!
}

input UpvoteCommentInput {
  upvote: Boolean
}

type UpvoteCommentPayload implements MutationPayload {
  query: Query!
  record: Comment!
}

type UpvotePostPayload implements MutationPayload {
  query: Query!
  record: Post!
}

type User {
  comments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, where: CommentWhereInput): CommentConnection!
  createdAt: DateTime!
  description: String
  desiredSkills(after: String, before: String, first: Int, last: Int, where: SkillWhereInput): SkillConnection!
  email: String!
  experiences: [Experience!]!
  followers(after: String, before: String, first: Int, last: Int, where: UserWhereInput): UserConnection!
  following(after: String, before: String, first: Int, last: Int, where: FollowWhereInput): FollowConnection!
  friendRequests(after: String, before: String, first: Int, last: Int, where: UserWhereInput): UserConnection!
  friends(after: String, before: String, first: Int, last: Int, where: UserWhereInput): UserConnection!
  github: GitHubUser!
  githubUrl: URL!
  id: ID!
  image: String
  name: String!
  posts(after: String, before: String, first: Int, last: Int, where: PostWhereInput): PostConnection!
  repositories: [Repository!]!
  skills(after: String, before: String, first: Int, last: Int, where: SkillWhereInput): SkillConnection!
  upvotedPosts(after: String, before: String, first: Int, last: Int, where: PostWhereInput): PostConnection!
  viewerFollowing: Boolean!
  viewerFriended: Boolean!
}

interface UserActivity {
  createdAt: DateTime!
  id: ID!
  user: User!
  userId: String!
}

union UserActivityItem = UserActivityItemCommentPost | UserActivityItemFollowSkill | UserActivityItemFollowUser | UserActivityItemFriendAcceptUser | UserActivityItemJoined | UserActivityItemPublishPost | UserActivityItemUpvotePost

type UserActivityItemCommentPost implements UserActivity {
  comment: Comment!
  commentId: String!
  createdAt: DateTime!
  id: ID!
  user: User!
  userId: String!
}

type UserActivityItemConnection implements Connection {
  edges: [UserActivityItemEdge!]!
  nodes: [UserActivityItem!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserActivityItemEdge {
  cursor: String!
  node: UserActivityItem!
}

type UserActivityItemFollowSkill implements UserActivity {
  createdAt: DateTime!
  follow: Follow!
  followId: String!
  id: ID!
  user: User!
  userId: String!
}

type UserActivityItemFollowUser implements UserActivity {
  createdAt: DateTime!
  follow: Follow!
  followId: String!
  id: ID!
  user: User!
  userId: String!
}

type UserActivityItemFriendAcceptUser implements UserActivity {
  createdAt: DateTime!
  friendship: Friendship!
  friendshipId: String!
  id: ID!
  user: User!
  userId: String!
}

type UserActivityItemJoined implements UserActivity {
  createdAt: DateTime!
  id: ID!
  user: User!
  userId: String!
}

type UserActivityItemPublishPost implements UserActivity {
  createdAt: DateTime!
  id: ID!
  post: Post!
  postId: String!
  user: User!
  userId: String!
}

type UserActivityItemUpvotePost implements UserActivity {
  createdAt: DateTime!
  id: ID!
  post: Post!
  postId: String!
  user: User!
  userId: String!
}

enum UserActivityType {
  CommentPost
  FollowSkill
  FollowUser
  FriendAcceptUser
  Joined
  PublishPost
  UpvotePost
}

input UserActivityWhereInput {
  type: UserActivityType
  user: UserWhereInput
}

# Relay-style connection for User types.
type UserConnection implements Connection {
  edges: [UserEdge!]!
  nodes: [User!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Relay-style edge for User types.
type UserEdge {
  cursor: String!
  node: User!
}

input UserOrderByInput {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input UserWhereInput {
  name: StringNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  name: String
}
